# AI Idle - Design & Technical Plan

This document translates the updated foundational decisions into a concrete plan for the first playable version of AI Idle. It emphasizes rapid iteration, clarity, and a lightweight toolchain suitable for a solo developer collaborating with Codex.

## 1. Project Overview
- **Audience:** Solely you; no commercial pressure, prioritize fun and learning.
- **Objective:** Deliver a desktop-playable idle game with satisfying number growth and an AI-focused tech ladder.
- **Design Philosophy:** Keep scope intentionally narrow, reinforce the feeling of advancement with each AI era, and bias toward systems that are easy to expand later.

## 2. Experience Goals
1. **"Number goes up" satisfaction:** Funding growth should be visible and accelerate when you make smart choices.
2. **Clear era progress:** Every new AI capability must outclass the previous era and feel like a genuine leap.
3. **Active choices matter:** Players can continually tweak talent allocation, research queues, pods, or boosts to optimize throughput even while idle gain persists.

## 3. MVP Definition
The minimum playable slice should include:
- One complete era (Data Labeling Frontier) with at least two production structures (e.g., *Crowd Annotator* and *Specialist Labeling Studio*).
- Core resources: `Funding`, `Talent`, `Research`, and scaffolding for `Data Flow` and `Compute` to support later eras.
- Actions: purchase/upgrade units, reallocate talent, trigger the Hackathon Sprint boost, and buy at least one multiplier upgrade.
- Basic UI showing totals and per-second rates for each resource, plus upgrade and research panels.
- Offline/closed-window accumulation with no penalties.
- Local save/load so progress resumes automatically.

Stretch (post-MVP) features include additional eras, a prestige loop, equipment or pod loadouts, and richer automation.

## 4. Core Gameplay Loops
### 4.1 Moment-to-moment loop
1. Observe resource totals and rates on the dashboard.
2. Spend funding on new units or upgrades.
3. Reassign talent or toggle modifiers to improve output.
4. Trigger the Hackathon Sprint for a temporary production spike with a short cooldown.

### 4.2 Short-term progression loop
1. Accumulate `Funding` and `Research`.
2. Unlock new buildings/tools inside the current era.
3. Meet the multi-resource requirement (funding, research, and later data flow/compute) for the next era.
4. Transition to the next era; newly unlocked content immediately surpasses the previous era’s efficiency.

### 4.3 Long-term loop (future roadmap)
- Introduce prestige/reset via an "AI Reboot" that trades current progress for persistent multipliers once multiple eras exist.
- Add experimental events or temporary modifiers to test balance adjustments.

## 5. Systems Breakdown
### 5.1 Resources
- **Funding:** Primary score and spending currency, generated by all operational units.
- **Talent:** Specialists required to operate units; upgrades and research can expand the pool.
- **Research:** Represents breakthroughs needed for upgrades, new units, and next-era unlocks.
- **Data Flow:** Mid-game gating resource representing curated datasets and deployment reach.
- **Compute:** Late-game resource used for foundation runs, pods, and certain upgrades.

### 5.2 Production Units
- Defined via declarative data: cost curve, production rate, talent requirement, optional upkeep.
- Example Data Labeling Frontier units:
  - `Crowd Annotator`: low cost, baseline talent usage, modest funding and research gain.
  - `Specialist Labeling Studio`: higher cost, faster annotation throughput, stronger research gain.

### 5.3 Upgrades & Modifiers
- Permanent upgrades grant multiplicative or additive boosts tied to units or global resources.
- Hackathon Sprint: manual boost button applying a temporary multiplier with cooldown.
- Hooks for future systems (equipment sets, automation toggles) remain available but out of MVP scope.

### 5.4 Era Progression
- Each era defined in TypeScript modules: id, name, flavor text, units, upgrades, unlock requirements.
- Transition triggers: pay the multi-resource cost; optionally require certain talent or research milestones.
- Previous era units remain but their relative efficiency drops, ensuring forward momentum.

### 5.5 Offline Simulation
- On load, compute elapsed real time since last save and apply passive gains in fixed time slices (e.g., 60-second chunks) to avoid instability.
- Respect upgrade multipliers and global bonuses when simulating offline production.

### 5.6 Save System
- Auto-save to `localStorage` every tick and on key actions.
- Offer manual export/import as a nice-to-have safety net.

## 6. Technical Architecture
### 6.1 Stack Selection
- **Frontend Framework:** React + TypeScript for component-based UI and strong tooling.
- **Build Tool:** Vite for fast dev server and modern bundling.
- **State Management:** Zustand for lightweight global store and simulation loop integration.
- **Styling:** CSS modules or Tailwind (dev preference); start simple and refactor later if needed.
- **Persistence:** Zustand persistence middleware syncing to `localStorage`.

### 6.2 Project Structure (current)
```
repo/
  src/
    components/
    data/
    state/
    utils/
  docs/
  designs/
  public/
```
- Era definitions stay in structured TypeScript files for rapid iteration.
- Simulation code lives in `src/state/` alongside selectors and derived data.

### 6.3 Tooling & Quality
- **Testing:** Vitest + React Testing Library for unit and integration coverage (focus on simulation math and store actions).
- **Linting/Formatting:** ESLint + Prettier configured for TypeScript.
- **Type Safety:** Strict TypeScript mode to catch regressions early.

## 7. Milestone Plan
1. **Project Bootstrap**
   - Initialize Vite + React + TS project structure.
   - Configure ESLint, Prettier, and optional CI checks.
2. **Core Simulation Engine**
   - Implement resource store, time-step simulation, and Hackathon Sprint stub.
   - Hardcode Data Labeling Frontier era data for first iteration.
3. **MVP UI Layer**
   - Build resource dashboard, unit purchasing panel, upgrade list, and boost controls.
   - Ensure numbers feel responsive and readable.
4. **Additional Eras & Systems**
   - Layer in Algorithmic Awakening, Cloud AI Services, Foundation Model Era, and Autonomous Intelligence using the same data pipeline.
   - Introduce data flow accelerator and pod orchestration once corresponding eras unlock.
5. **Polish & Balance**
   - Tune pacing so each era unlock hits within a satisfying session length.
   - Add basic audio/visual feedback for major actions.
6. **Post-MVP**
   - Explore prestige loop, advanced automation, and expanded leaderboard views.

## 8. Risks & Mitigations
- **Balance Complexity:** Idle pacing is sensitive. Mitigate by logging production metrics and writing small tuning scripts.
- **Scope Creep:** Stick to defined systems until the AI era ladder feels tight. Capture future ideas in `designs/`.
- **Tool Familiarity:** If React/Zustand ever feels heavy, prototype alternative structures quickly before doubling down.
- **Codex Reliability:** Maintain frequent commits and manual testing to catch integration issues early.

## 9. Immediate Next Actions
1. Finish retheme sweep across docs, UI, and data (in progress).
2. Continue balancing AI eras with new terminology and effects.
3. Plan prestige/reset mechanics once current eras feel stable.

Use this plan as a living reference—update sections as systems evolve or priorities shift.